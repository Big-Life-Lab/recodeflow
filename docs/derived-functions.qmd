---
title: Scope for Derived Functions
---

## Objective

The objective of this document is to define the scope and specifications for the development of recodeflow derived functions

## Context

The variables and variable details sheet within the recodeflow library enables a user
to encode simple recoding rules. For example, collapsing two categories into one,
mapping an interval in a continuous variable to a category etc. However, it does not
support rules that contain complex operations like mathematical operations and conditional
logic. When a variable requires such logic the user will need to use a derived variable.

A derived variable is simply a variable that requires a function in order to execute
it recoding rules. A good example of this is BMI which requires mathematical operations
for its calculations and can also contain conditional logic if the user wishes to
do some logic to validate the inputs. This document will go over the scope and specifications
for such derived variables and functions used to derive them.

## Scope

### Function Language

The library should support only functions written in R. Although it looks like the
R ecosystem is moving towards allowing the execution of other statistical languages
particularly [Python](https://cran.r-project.org/web/packages/reticulate/vignettes/calling_python.html)
within its process, the library for now needs only support R functions.

### Function Inputs and Outputs

The inputs and outputs to the functions should be standardized so that they're all of the same type
whether that is a scalar or a vector.

For example, assume the following BMI function,

```{r}
BMI <- function(weight, height) {
    return(weight/height*height)
}
```

The library should make a decision on whether the inputs weight and height can be scalar values
for example 80 and 180 or vector values like c(80, 70) and c(180, 150).

Scalar values may make the function more portable in contexts other than the library
but could reduce the performance of the library.

```{r}
scalar <- function(data) {
    bmi <- c()
    for(i in 1:nrow(data)) {
       bmi <- c(bmi, BMI(data[i, "weight"], data[i, "height"]))
    }
}

vectorized <- function(data) {
    bmi <- BMI(data$weight, data$height)
}

test_data <- data.frame(weight = sample(1:100, 1000, replace = TRUE), height = sample(1:100, 1000, replace = TRUE))

scalar_start_time <- Sys.time()
scalar(test_data)
scalar_end_time <- Sys.time()
scalar_time <- scalar_end_time - scalar_start_time
print(scalar_time)

vector_start_time <- Sys.time()
vectorized(test_data)
vector_end_time <- Sys.time()
vector_time <- vector_end_time - vector_start_time
print(vector_time)
```

Ergonomically, using a vector is better suited for majority of cases since datasets
are usually in data frames and the individual columns can be easily plucked out as
vectors using the $ operator. Scalars are better suited if coming from a non-statistical
language like Python or Javascript where the mental model is all about scalars.

### Supported Operations

The library should allow the user to use any kind of code supported by R within
the functions. This can mean using functions from other R files, using libraries,
using if loops etc.


