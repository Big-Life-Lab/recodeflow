<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Customizing styler</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Customizing styler</h1>



<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>knitr<span class="sc">::</span>opts_chunk<span class="sc">$</span><span class="fu">set</span>(</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>  <span class="at">collapse =</span> <span class="cn">TRUE</span>,</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>  <span class="at">comment =</span> <span class="st">&quot;#&gt;&quot;</span></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>)</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="fu">options</span>(<span class="at">styler.colored_print.vertical =</span> <span class="cn">FALSE</span>)</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>styler<span class="sc">::</span><span class="fu">cache_deactivate</span>()</span></code></pre></div>
<pre><code>## Deactivated cache.</code></pre>
<p>This vignette provides a high-level overview of how styler works and
how you can define your own style guide and format code according to it.
If you simply want to customize the tidyverse style guide to your needs,
check out <code>vignette(&quot;styler&quot;)</code>, to remove some rules, have a
look at <code>vignette(&quot;remove_rules&quot;)</code>. How to distribute a
custom style guide is described in
<code>vignette(&quot;distribute_custom_style_guides&quot;)</code>.</p>
<div id="how-styler-works" class="section level1">
<h1>How styler works</h1>
<p>There are three major steps that styler performs in order to style
code:</p>
<ol style="list-style-type: decimal">
<li><p>Create an abstract syntax tree (AST) from
<code>utils::getParseData()</code> that contains positional information
for every token. We call this a nested parse table.</p></li>
<li><p>Apply transformer functions at each level of the nested parse
table. We use a visitor approach, i.e. a function that takes functions
as arguments and applies them to every level of nesting. You can find
out more about it on the help file for <code>visit()</code>. Note that
the function is not exported by styler. The visitor will take care of
applying the functions on every level of nesting - and we can supply
transformer functions that operate on one level of nesting. In the
sequel, we use the term <em>nest</em> to refer to such a parse table at
one level of nesting. A <em>nest</em> always represents a complete
expression. Before we apply the transformers, we have to initialize two
columns <code>lag_newlines</code> and <code>spaces</code>, which contain
the number of line breaks before the token and the number of spaces
after the token. These will be the columns that most of our transformer
functions will modify.</p></li>
<li><p>Serialize the nested parse table, that is, extract the terminal
tokens from the nested parse table and add spaces and line breaks
between them as specified in the nested parse table.</p></li>
</ol>
<p>The <code>transformers</code> argument is, apart from the code to
style, the key argument of functions such as <code>style_text()</code>
and friends. By default, it is created via the <code>style</code>
argument. The transformers are a named list of transformer functions and
other arguments passed to styler. To use the default style guide of
styler (<a href="https://style.tidyverse.org/">the tidyverse style
guide</a>), call <code>tidyverse_style()</code> to get the list of the
transformer functions. Let’s quickly look at what those are.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="fu">library</span>(<span class="st">&quot;styler&quot;</span>)</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="fu">library</span>(<span class="st">&quot;magrittr&quot;</span>)</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a><span class="fu">cache_deactivate</span>()</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a><span class="co">#&gt; Deactivated cache.</span></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a><span class="fu">names</span>(<span class="fu">tidyverse_style</span>())</span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a><span class="co">#&gt;  [1] &quot;initialize&quot;             &quot;line_break&quot;             &quot;space&quot;                 </span></span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a><span class="co">#&gt;  [4] &quot;token&quot;                  &quot;indention&quot;              &quot;use_raw_indention&quot;     </span></span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a><span class="co">#&gt;  [7] &quot;reindention&quot;            &quot;style_guide_name&quot;       &quot;style_guide_version&quot;   </span></span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a><span class="co">#&gt; [10] &quot;more_specs_style_guide&quot; &quot;transformers_drop&quot;      &quot;indent_character&quot;</span></span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a><span class="fu">str</span>(<span class="fu">tidyverse_style</span>(), <span class="at">give.attr =</span> <span class="cn">FALSE</span>, <span class="at">list.len =</span> <span class="dv">3</span>)</span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a><span class="co">#&gt; List of 12</span></span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a><span class="co">#&gt;  $ initialize            :List of 1</span></span>
<span id="cb3-13"><a href="#cb3-13" tabindex="-1"></a><span class="co">#&gt;   ..$ initialize:function (pd_flat)  </span></span>
<span id="cb3-14"><a href="#cb3-14" tabindex="-1"></a><span class="co">#&gt;  $ line_break            :List of 12</span></span>
<span id="cb3-15"><a href="#cb3-15" tabindex="-1"></a><span class="co">#&gt;   ..$ set_line_break_around_comma_and_or                :function (pd, strict)  </span></span>
<span id="cb3-16"><a href="#cb3-16" tabindex="-1"></a><span class="co">#&gt;   ..$ set_line_break_after_assignment                   :function (pd)  </span></span>
<span id="cb3-17"><a href="#cb3-17" tabindex="-1"></a><span class="co">#&gt;   ..$ set_line_break_before_curly_opening               :function (pd)  </span></span>
<span id="cb3-18"><a href="#cb3-18" tabindex="-1"></a><span class="co">#&gt;   .. [list output truncated]</span></span>
<span id="cb3-19"><a href="#cb3-19" tabindex="-1"></a><span class="co">#&gt;  $ space                 :List of 19</span></span>
<span id="cb3-20"><a href="#cb3-20" tabindex="-1"></a><span class="co">#&gt;   ..$ remove_space_before_closing_paren :function (pd_flat)  </span></span>
<span id="cb3-21"><a href="#cb3-21" tabindex="-1"></a><span class="co">#&gt;   ..$ remove_space_before_opening_paren :function (pd_flat)  </span></span>
<span id="cb3-22"><a href="#cb3-22" tabindex="-1"></a><span class="co">#&gt;   ..$ add_space_after_for_if_while      :function (pd_flat)  </span></span>
<span id="cb3-23"><a href="#cb3-23" tabindex="-1"></a><span class="co">#&gt;   .. [list output truncated]</span></span>
<span id="cb3-24"><a href="#cb3-24" tabindex="-1"></a><span class="co">#&gt;   [list output truncated]</span></span></code></pre></div>
<p>We note that there are different types of transformer functions.
<code>initialize</code> initializes some variables in the nested parse
table (so it is not actually a transformer), and the other elements
modify either spacing, line breaks or tokens.
<code>use_raw_indention</code> is not a function, it is just an option.
All transformer functions have a similar structure. Let’s take a look at
one:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="fu">tidyverse_style</span>()<span class="sc">$</span>space<span class="sc">$</span>remove_space_after_opening_paren</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a><span class="co">#&gt; function (pd_flat) </span></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a><span class="co">#&gt; {</span></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a><span class="co">#&gt;     paren_after &lt;- pd_flat$token %in% c(&quot;&#39;(&#39;&quot;, &quot;&#39;[&#39;&quot;, &quot;LBB&quot;)</span></span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a><span class="co">#&gt;     if (!any(paren_after)) {</span></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a><span class="co">#&gt;         return(pd_flat)</span></span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a><span class="co">#&gt;     }</span></span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a><span class="co">#&gt;     pd_flat$spaces[paren_after &amp; (pd_flat$newlines == 0L)] &lt;- 0L</span></span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a><span class="co">#&gt;     pd_flat</span></span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a><span class="co">#&gt; }</span></span>
<span id="cb4-11"><a href="#cb4-11" tabindex="-1"></a><span class="co">#&gt; &lt;bytecode: 0x14be48878&gt;</span></span>
<span id="cb4-12"><a href="#cb4-12" tabindex="-1"></a><span class="co">#&gt; &lt;environment: namespace:styler&gt;</span></span></code></pre></div>
<p>As the name says, this function removes spaces after the opening
parenthesis. But how? Its input is a <em>nest</em>. Since the visitor
will go through all levels of nesting, we just need a function that can
be applied to a <em>nest</em>, that is, to a parse table at one level of
nesting. We can compute the nested parse table and look at one of the
levels of nesting that is interesting for us (more on the data structure
in the vignettes “Data structures” and “Manipulating the parse
table”):</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>string_to_format <span class="ot">&lt;-</span> <span class="st">&quot;call( 3)&quot;</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>pd <span class="ot">&lt;-</span> styler<span class="sc">:::</span><span class="fu">compute_parse_data_nested</span>(string_to_format) <span class="sc">%&gt;%</span></span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>  styler<span class="sc">:::</span><span class="fu">pre_visit_one</span>(default_style_guide_attributes)</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>cols <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&#39;token&#39;</span>, <span class="st">&#39;terminal&#39;</span>, <span class="st">&#39;text&#39;</span>, <span class="st">&#39;newlines&#39;</span>, <span class="st">&#39;spaces&#39;</span>)</span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>pd<span class="sc">$</span>child[[<span class="dv">1</span>]][, cols]</span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a><span class="co">#&gt;   token terminal text newlines spaces</span></span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a><span class="co">#&gt; 1  expr    FALSE call        0      0</span></span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a><span class="co">#&gt; 2   &#39;(&#39;     TRUE    (        0      1</span></span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a><span class="co">#&gt; 3  expr    FALSE    3        0      0</span></span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a><span class="co">#&gt; 4   &#39;)&#39;     TRUE    )        0      0</span></span></code></pre></div>
<p><code>default_style_guide_attributes()</code> is called to initialize
some variables, it does not actually transform the parse table.</p>
<p>All the function <code>remove_space_after_opening_paren()</code> now
does is to look for the opening bracket and set the column
<code>spaces</code> of the token to zero. Note that it is very important
to check whether there is also a line break following after that token.
If so, <code>spaces</code> should not be touched because of the way
<code>spaces</code> and <code>newlines</code> are defined.
<code>spaces</code> are the number of spaces after a token and
<code>newlines</code>. Hence, if a line break follows, spaces are not
EOL spaces, but rather the spaces directly before the next token. If
there was a line break after the token and the rule did not check for
that, indention for the token following <code>(</code> would be removed.
This would be unwanted for example if <code>use_raw_indention</code> is
set to <code>TRUE</code> (which means indention should not be touched).
If we apply the rule to our parse table, we can see that the column
<code>spaces</code> changes and is now zero for all tokens:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>styler<span class="sc">:::</span><span class="fu">remove_space_after_opening_paren</span>(pd<span class="sc">$</span>child[[<span class="dv">1</span>]])[, cols]</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="co">#&gt;   token terminal text newlines spaces</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a><span class="co">#&gt; 1  expr    FALSE call        0      0</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="co">#&gt; 2   &#39;(&#39;     TRUE    (        0      0</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a><span class="co">#&gt; 3  expr    FALSE    3        0      0</span></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a><span class="co">#&gt; 4   &#39;)&#39;     TRUE    )        0      0</span></span></code></pre></div>
<p>All top-level styling functions have a <code>style</code> argument
(which defaults to <code>tidyverse_style</code>). If you check out the
help file, you can see that the argument <code>style</code> is only used
to create the default <code>transformers</code> argument, which defaults
to <code>style(...)</code>. This allows for the styling options to be
set without having to specify them inside the function passed to
<code>transformers</code>.</p>
<p>Let’s clarify this with an example. The following yields the same
result:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="fu">all.equal</span>(</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>  <span class="fu">style_text</span>(string_to_format, <span class="at">transformers =</span> <span class="fu">tidyverse_style</span>(<span class="at">strict =</span> <span class="cn">FALSE</span>)),</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>  <span class="fu">style_text</span>(string_to_format, <span class="at">style =</span> tidyverse_style, <span class="at">strict =</span> <span class="cn">FALSE</span>),</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>  <span class="fu">style_text</span>(string_to_format, <span class="at">strict =</span> <span class="cn">FALSE</span>),</span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a>)</span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>Now let’s do the whole styling of a string with just this one
transformer introduced above. We do this by first creating a style guide
with the designated wrapper function <code>create_style_guide()</code>.
It takes transformer functions as input and returns them in a named list
that meets the formal requirements for styling functions. We also set a
name and version of the style guide according to the convention outlined
in <code>create_style_guide()</code>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>space_after_opening_style <span class="ot">&lt;-</span> <span class="cf">function</span>(are_you_sure) {</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>  <span class="fu">create_style_guide</span>(</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>    <span class="at">space =</span> <span class="fu">list</span>(<span class="at">remove_space_after_opening_paren =</span> </span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>    <span class="cf">if</span> (are_you_sure) styler<span class="sc">:::</span>remove_space_after_opening_paren),</span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>    <span class="at">style_guide_name =</span> <span class="st">&quot;styler::space_after_opening_style@https://github.com/r-lib/styler&quot;</span>,</span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>    <span class="at">style_guide_version =</span> <span class="fu">read.dcf</span>(here<span class="sc">::</span><span class="fu">here</span>(<span class="st">&quot;DESCRIPTION&quot;</span>))[, <span class="st">&quot;Version&quot;</span>]</span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a>  )</span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a>}</span></code></pre></div>
<p>Make sure to also disable caching during development with
<code>cache_deactivate()</code> because styling the same text with a
different style guide that has the same version and name will fool the
cache invalidation in the case your style guide has transformer
functions with different function bodies. Make sure to increment the
version number of your style guide with every release. It should
correspond to the version of the package from which you export your
style guide.</p>
<p>We can not try the style guide:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="fu">style_text</span>(<span class="st">&quot;call( 1,1)&quot;</span>, <span class="at">style =</span> space_after_opening_style, <span class="at">are_you_sure =</span> <span class="cn">TRUE</span>)  </span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="co">#&gt; call(1,1)</span></span></code></pre></div>
<p>Note that the return value of your <code>style</code> function may
not contain <code>NULL</code> elements.</p>
<p>I hope you have acquired a basic understanding of how styler
transforms code. You can provide your own transformer functions and use
<code>create_style_guide()</code> to create customized code styling. If
you do so, there are a few more things you should be aware of, which are
described in the next section.</p>
</div>
<div id="implementation-details" class="section level1">
<h1>Implementation details</h1>
<p>For both spaces and line break information in the nested parse table,
we use four attributes in total: <code>newlines</code>,
<code>lag_newlines</code>, <code>spaces</code>, and
<code>lag_spaces</code>. <code>lag_spaces</code> is created from
<code>spaces</code> only just before the parse table is serialized, so
it is not relevant for manipulating the parse table as described above.
These columns are to some degree redundant, but with just lag or lead,
we would lose information on the first or the last element respectively,
so we need both.</p>
<p>The sequence in which styler applies rules on each level of nesting
is given in the list below:</p>
<ul>
<li><p>call <code>default_style_guide_attributes()</code> to initialize
some variables.</p></li>
<li><p>modify the line breaks (modifying <code>lag_newlines</code> only
based on <code>token</code>, <code>token_before</code>,
<code>token_after</code> and <code>text</code>).</p></li>
<li><p>modify the spaces (modifying <code>spaces</code> only based on
<code>lag_newlines</code>, <code>newlines</code>,
<code>multi_line</code>, <code>token</code>, <code>token_before</code>,
<code>token_after</code> and <code>text</code>).</p></li>
<li><p>modify the tokens (based on <code>newlines</code>
<code>lag_newlines</code>, <code>spaces</code> <code>multi_line</code>,
<code>token</code>, <code>token_before</code>, <code>token_after</code>
and <code>text</code>).</p></li>
<li><p>modify the indention by changing <code>indention_ref_id</code>
(based on <code>newlines</code> <code>lag_newlines</code>,
<code>spaces</code> <code>multi_line</code>, <code>token</code>,
<code>token_before</code>, <code>token_after</code> and
<code>text</code>).</p></li>
</ul>
<p>You can also look this up in the function that applies the
transformers: <code>apply_transformers()</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>styler<span class="sc">:::</span>apply_transformers</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a><span class="co">#&gt; function (pd_nested, transformers) </span></span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a><span class="co">#&gt; {</span></span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a><span class="co">#&gt;     transformed_updated_multi_line &lt;- post_visit(pd_nested, c(transformers$initialize, </span></span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a><span class="co">#&gt;         transformers$line_break, set_multi_line, if (length(transformers$line_break) != </span></span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a><span class="co">#&gt;             0L) update_newlines))</span></span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a><span class="co">#&gt;     transformed_all &lt;- pre_visit(transformed_updated_multi_line, </span></span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a><span class="co">#&gt;         c(transformers$space, transformers$indention, transformers$token))</span></span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a><span class="co">#&gt;     transformed_absolute_indent &lt;- context_to_terminals(transformed_all, </span></span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a><span class="co">#&gt;         outer_lag_newlines = 0L, outer_indent = 0L, outer_spaces = 0L, </span></span>
<span id="cb10-11"><a href="#cb10-11" tabindex="-1"></a><span class="co">#&gt;         outer_indention_refs = NA)</span></span>
<span id="cb10-12"><a href="#cb10-12" tabindex="-1"></a><span class="co">#&gt;     transformed_absolute_indent</span></span>
<span id="cb10-13"><a href="#cb10-13" tabindex="-1"></a><span class="co">#&gt; }</span></span>
<span id="cb10-14"><a href="#cb10-14" tabindex="-1"></a><span class="co">#&gt; &lt;bytecode: 0x14a31e150&gt;</span></span>
<span id="cb10-15"><a href="#cb10-15" tabindex="-1"></a><span class="co">#&gt; &lt;environment: namespace:styler&gt;</span></span></code></pre></div>
<p>This means that the order of the styling is clearly defined and it is
for example not possible to modify line breaks based on spacing, because
spacing will be set after line breaks are set. Do not rely on the column
<code>col1</code>, <code>col2</code>, <code>line1</code> and
<code>line2</code> in the parse table in any of your functions since
these columns only reflect the position of tokens at the point of
parsing,</p>
<p>i.e. they are not kept up to date throughout the process of
styling.</p>
<p>Also, as indicated above, work with <code>lag_newlines</code> only in
your line break rules. For development purposes, you may also want to
use the unexported function <code>test_collection()</code> to help you
with testing your style guide. You can find more information in the help
file for the function.</p>
<p>If you write functions that modify spaces, don’t forget to make sure
that you don’t modify EOL spacing, since that is needed for
<code>use_raw_indention</code>, as highlighted previously.</p>
<p>Finally, take note of the naming convention. All function names
starting with <code>set-*</code> correspond to the <code>strict</code>
option, that is, setting some value to an exact number.
<code>add-*</code> is softer. For example,
<code>add_spaces_around_op()</code>, only makes sure that there is at
least one space around operators, but if the code to style contains
multiple, the transformer will not change that.</p>
</div>
<div id="showcasing-the-development-of-a-styling-rule" class="section level1">
<h1>Showcasing the development of a styling rule</h1>
<p>For illustrative purposes, we create a new style guide that has one
rule only: Curly braces are always on a new line. So for example:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>add_one <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>  x <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>}</span></code></pre></div>
<p>Should be transformed to:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>add_one <span class="ot">&lt;-</span> <span class="cf">function</span>(x) </span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>{</span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>  x <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>}</span></code></pre></div>
<p>We first need to get familiar with the structure of the nested parse
table. Note that the structure of the nested parse table is not affected
by the position of line breaks and spaces. Let’s first create the nested
parse table.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>code <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;add_one &lt;- function(x) { x + 1 }&quot;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>styler<span class="sc">:::</span><span class="fu">create_tree</span>(code)</span></code></pre></div>
<pre><code> ##                                              levelName
 ## 1  ROOT (token: short_text [lag_newlines/spaces] {id})
 ## 2   °--expr:  [0/0] {23}                              
 ## 3       ¦--expr:  [0/1] {3}                           
 ## 4       ¦   °--SYMBOL: add_o [0/0] {1}                
 ## 5       ¦--LEFT_ASSIGN: &lt;- [0/1] {2}                  
 ## 6       °--expr:  [0/0] {22}                          
 ## 7           ¦--FUNCTION: funct [0/0] {4}              
 ## 8           ¦--&#39;(&#39;: ( [0/0] {5}                       
 ## 9           ¦--SYMBOL_FORMALS: x [0/0] {6}            
 ## 10          ¦--&#39;)&#39;: ) [0/1] {7}                       
 ## 11          °--expr:  [0/0] {19}                      
 ## 12              ¦--&#39;{&#39;: { [0/1] {9}                   
 ## 13              ¦--expr:  [0/1] {16}                  
 ## 14              ¦   ¦--expr:  [0/1] {12}              
 ## 15              ¦   ¦   °--SYMBOL: x [0/0] {10}       
 ## 16              ¦   ¦--&#39;+&#39;: + [0/1] {11}              
 ## 17              ¦   °--expr:  [0/0] {14}              
 ## 18              ¦       °--NUM_CONST: 1 [0/0] {13}    
 ## 19              °--&#39;}&#39;: } [0/0] {15}</code></pre>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>pd <span class="ot">&lt;-</span> styler<span class="sc">:::</span><span class="fu">compute_parse_data_nested</span>(code)</span></code></pre></div>
<p>The token of interest here has id number 10. Let’s navigate there.
Since line break rules manipulate the lags <em>before</em> the token, we
need to change <code>lag_newlines</code> at the token “‘{’”.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>pd<span class="sc">$</span>child[[<span class="dv">1</span>]]<span class="sc">$</span>child[[<span class="dv">3</span>]]<span class="sc">$</span>child[[<span class="dv">5</span>]]</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a><span class="co">#&gt;   id pos_id line1 col1 line2 col2 parent token terminal  text short</span></span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a><span class="co">#&gt; 1  9     11     1   24     1   24     19   &#39;{&#39;     TRUE     {     {</span></span>
<span id="cb17-4"><a href="#cb17-4" tabindex="-1"></a><span class="co">#&gt; 2 16     12     1   26     1   30     19  expr    FALSE x + 1 x + 1</span></span>
<span id="cb17-5"><a href="#cb17-5" tabindex="-1"></a><span class="co">#&gt; 3 15     18     1   32     1   32     19   &#39;}&#39;     TRUE     }     }</span></span>
<span id="cb17-6"><a href="#cb17-6" tabindex="-1"></a><span class="co">#&gt;   token_before token_after stylerignore block is_cached internal</span></span>
<span id="cb17-7"><a href="#cb17-7" tabindex="-1"></a><span class="co">#&gt; 1          &#39;)&#39;      SYMBOL        FALSE    NA     FALSE    FALSE</span></span>
<span id="cb17-8"><a href="#cb17-8" tabindex="-1"></a><span class="co">#&gt; 2         &lt;NA&gt;        &lt;NA&gt;        FALSE    NA     FALSE    FALSE</span></span>
<span id="cb17-9"><a href="#cb17-9" tabindex="-1"></a><span class="co">#&gt; 3    NUM_CONST                    FALSE    NA     FALSE    FALSE</span></span>
<span id="cb17-10"><a href="#cb17-10" tabindex="-1"></a><span class="co">#&gt;                                                                                                                                                                                                                                                                                                                                                                                                                    child</span></span>
<span id="cb17-11"><a href="#cb17-11" tabindex="-1"></a><span class="co">#&gt; 1                                                                                                                                                                                                                                                                                                                                                                                                                   NULL</span></span>
<span id="cb17-12"><a href="#cb17-12" tabindex="-1"></a><span class="co">#&gt; 2 12, 11, 14, 14, 15, 17, 1, 1, 1, 26, 28, 30, 1, 1, 1, 26, 28, 30, 16, 16, 16, expr, &#39;+&#39;, expr, FALSE, TRUE, FALSE, x, +, 1, x, +, 1, NA, SYMBOL, NA, NA, NUM_CONST, NA, FALSE, FALSE, FALSE, NA, NA, NA, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 13, 10, 1, 26, 1, 26, 12, SYMBOL, TRUE, x, x, &#39;{&#39;, &#39;+&#39;, FALSE, NA, FALSE, FALSE, 16, 13, 1, 30, 1, 30, 14, NUM_CONST, TRUE, 1, 1, &#39;+&#39;, &#39;}&#39;, FALSE, NA, FALSE, FALSE</span></span>
<span id="cb17-13"><a href="#cb17-13" tabindex="-1"></a><span class="co">#&gt; 3                                                                                                                                                                                                                                                                                                                                                                                                                   NULL</span></span></code></pre></div>
<p>Remember what we said above: A transformer takes a flat parse table
as input, updates it and returns it. So here it’s actually simple:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>set_line_break_before_curly_opening <span class="ot">&lt;-</span> <span class="cf">function</span>(pd_flat) {</span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a>  op <span class="ot">&lt;-</span> pd_flat<span class="sc">$</span>token <span class="sc">%in%</span> <span class="st">&quot;&#39;{&#39;&quot;</span></span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a>  pd_flat<span class="sc">$</span>lag_newlines[op] <span class="ot">&lt;-</span> 1L</span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a>  pd_flat</span>
<span id="cb18-5"><a href="#cb18-5" tabindex="-1"></a>}</span></code></pre></div>
<p>Almost done. Now, the last thing we need to do is to use
<code>create_style_guide()</code> to create our style guide consisting
of that function.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a>set_line_break_before_curly_opening_style <span class="ot">&lt;-</span> <span class="cf">function</span>() {</span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>  <span class="fu">create_style_guide</span>(</span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a>    <span class="at">line_break =</span> <span class="fu">list</span>(set_line_break_before_curly_opening),</span>
<span id="cb19-4"><a href="#cb19-4" tabindex="-1"></a>    <span class="at">style_guide_name =</span> <span class="st">&quot;styler::set_line_break_before_curly_opening_style@https://github.com/r-lib/styler&quot;</span>,</span>
<span id="cb19-5"><a href="#cb19-5" tabindex="-1"></a>    <span class="at">style_guide_version =</span> <span class="fu">read.dcf</span>(here<span class="sc">::</span><span class="fu">here</span>(<span class="st">&quot;DESCRIPTION&quot;</span>))[, <span class="st">&quot;Version&quot;</span>]</span>
<span id="cb19-6"><a href="#cb19-6" tabindex="-1"></a>  )</span>
<span id="cb19-7"><a href="#cb19-7" tabindex="-1"></a>}</span></code></pre></div>
<p>Now you can style your string according to it.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a><span class="fu">style_text</span>(code, <span class="at">style =</span> set_line_break_before_curly_opening_style)</span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a><span class="co">#&gt; add_one &lt;- function(x)</span></span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a><span class="co">#&gt; { x + 1 }</span></span></code></pre></div>
<p>Note that when removing line breaks, always take care of comments,
since you don’t want:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a>a <span class="ot">&lt;-</span> <span class="cf">function</span>() <span class="co"># comments should remain EOL</span></span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>{ </span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a>  <span class="dv">3</span></span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a>}</span></code></pre></div>
<p>To become:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a>a <span class="ot">&lt;-</span> <span class="cf">function</span>() <span class="co"># comments should remain EOL { </span></span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a>  <span class="dv">3</span></span>
<span id="cb22-3"><a href="#cb22-3" tabindex="-1"></a><span class="er">}</span></span></code></pre></div>
<p>The easiest way of taking care of that is not applying the rule if
there is a comment before the token of interest, which can be checked
for within your transformer function. The transformer function from the
tidyverse style that removes line breaks before the round closing
bracket that comes after a curly brace looks as follows:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a>styler<span class="sc">:::</span>remove_line_break_before_round_closing_after_curly</span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a><span class="co">#&gt; function (pd) </span></span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a><span class="co">#&gt; {</span></span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a><span class="co">#&gt;     round_after_curly &lt;- pd$token == &quot;&#39;)&#39;&quot; &amp; (pd$token_before == </span></span>
<span id="cb23-5"><a href="#cb23-5" tabindex="-1"></a><span class="co">#&gt;         &quot;&#39;}&#39;&quot;)</span></span>
<span id="cb23-6"><a href="#cb23-6" tabindex="-1"></a><span class="co">#&gt;     pd$lag_newlines[round_after_curly] &lt;- 0L</span></span>
<span id="cb23-7"><a href="#cb23-7" tabindex="-1"></a><span class="co">#&gt;     pd</span></span>
<span id="cb23-8"><a href="#cb23-8" tabindex="-1"></a><span class="co">#&gt; }</span></span>
<span id="cb23-9"><a href="#cb23-9" tabindex="-1"></a><span class="co">#&gt; &lt;bytecode: 0x14bd325d8&gt;</span></span>
<span id="cb23-10"><a href="#cb23-10" tabindex="-1"></a><span class="co">#&gt; &lt;environment: namespace:styler&gt;</span></span></code></pre></div>
<p>With our example function
<code>set_line_break_before_curly_opening()</code> we don’t need to
worry about that as we are only adding line breaks, but we don’t remove
them.</p>
</div>
<div id="cache-invalidation" class="section level1">
<h1>Cache invalidation</h1>
<p>Note that it if you re-distribute the style guide, it’s your
responsibility to set the version and the style guide name in
<code>create_style_guide()</code> correctly. If you distribute a new
version of your style guide and you don’t increment the version number,
it might have drastic consequences for your user: Under some
circumstances (see <code>help(&quot;cache_make_key&quot;)</code>), your new style
guide won’t invalidate the cache although it should and applying your
style guide to code that has previously been styled won’t result in any
change. There is currently no mechanism in styler that prevents you from
making this mistake.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
