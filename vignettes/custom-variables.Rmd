---
title: "Custom Variables"
author: "Yulric Sequeira"
date: "2022-10-28"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The role of a custom variable is to avoid the duplication of work that can happen when recoding two variables with the same specification but that represent different information. For example, imagine a database with two columns called `PL` and `SL` that encodes the primary and secondary language that an individual speaks. Both columns are categorical with the same set of categories, **English**, **French**, **Mandarin**, **Hindi** and **N/A**. The last category represents a missing value. An example dataset is shown below,

```{r}
example_dataset <- read.csv(file.path("../assets/vignettes/custom-variables/example-dataset.csv"), fileEncoding = "UTF-8-BOM")

DT::datatable(example_dataset)
```

If we want to use these language variables in a study, we should probably assign a unique number to each category, effectively converting both variables to a numeric categorical variable. We want to **recode** the above example dataset to the one below,

```{r}
example_dataset <- read.csv(file.path("../assets/vignettes/custom-variables/recoded-dataset.csv"), fileEncoding = "UTF-8-BOM")

DT::datatable(example_dataset)
```

The recoding will create two new categorical variables, `primary_lang` and `secondary_lang` from the `PL` and `SL` respectively with the recoding rules shown below,

```{r}
recodeing_rules <- data.frame(
  language = c("English", "French", "Mandarin", "Hindi", "N/A"),
  recoded_value = c(1,2,3,4,999)
)

DT::datatable(recodeing_rules)
```

The variable details sheet which encodes the recoding rules above is shown below,

```{r}
variable_details <- read.csv(file.path("../assets/vignettes/custom-variables/no-custom-variable-variable-details.csv"), fileEncoding = "UTF-8-BOM")

DT::datatable(variable_details)
```

Both variables have 6 rows that encode the recoding rules, four for each language category, one for the `N/A` category, and a final else rule as a catch all for any missed categories. Notice how the specification for both variables are exactly the same, all the categories and recoding rules are identical, the only differences are the variables on which the rules are applied. This makes sense, both variables have the same specification (the same categories) but represent difference concepts (different variable names and labels). Without using a **custom variable** to represent these rules may be a non-issue for just two variables and five categories but imagine this situation scaled to 8 variables and 132 categories! A real use case that prompted this feature, it would be tiring to create the specifications as well as maintain them.

The `customVariable` column allows you to specify a "virtual variable", a variable that does not exist in the database, but whose specification can be used by other variables in the database. For example, we can rewrite the above variables details sheet using a custom variables called `language`.

```{r}
variable_details <- read.csv(file.path("../assets/vignettes/custom-variables/custom-variable-variable-details.csv"), fileEncoding = "UTF-8-BOM")

DT::datatable(variable_details)
```

In the above sheet we have defined a new custom variable called `language` (rows 1 to 6) which provides the reusable specifications for other languages in the database. The custom variable can now be reused in other concrete variables in the database like the `primary_language` and `secondary_language` variables as defined in rows 7 and 8. To use a custom variable, simply set the `customVariable` column to the name of the custom variable.

As we can see, by creating a custom variable we can reduce the number of rows in our variable details sheet but more importantly reduce the duplication of rows, which in turn increases maintainability of our sheet.

## Working with custom variables

The `customVariable` column can have one of the following values:

1. **Yes**: Value to set when the row is defining a custom variable
2. **No**: Value to set when the row is defining a normal variable that **does not** extend a custom variable
3. **<custom_variable_name>**: The name of a custom variable that this row is extending

When creating a custom variable, 

1. The `variable` column should the name of the custom variable
2. The `customVariable` column should be Yes
3. The `variableStart` and `variableStartLabel` column should be `N/A`. Variables that extend the custom variable will set them.

When extending a custom variable,

1. The custom variable column should be set to the name of the custom variable being extended
2. The `typeEnd`, `typeStart`, `databaseStart` columns should be equal to value set in the custom variable. The `numValidCat`, `catLabel`, `catLabeLong`, `units`, `recStart`, and `catStartLabel` should set to N/A. These will come from the custom variable.
3. If the variable is a derived variable then the `recStart` column can be set to a function, otherwise it should be `N/A`.
