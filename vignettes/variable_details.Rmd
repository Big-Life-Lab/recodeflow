---
title: "variable_details worksheet"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{variable_details.csv}     
  %\VignetteEngine{knitr::rmarkdown} 
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

## Introduction

The worksheet `variable_details` maps variables across datasets. `variable_details` also contains the instructions for function `rec_with_table` on how to transform the variables listed in the worksheet `variables_sheet`.

Specifically, the function `rec_with-table` transforms variables listed in column `variable_details$variableStart` to the variables listed in `variable_details$variable`. 

```{r Read variables.csv, echo=FALSE, message=FALSE, warning=FALSE}
library(readr)
library(DT)
library(knitr)
library(kableExtra)

source("../R/test_data_generator.R")

datatable(variable_details, options = list(pageLength = 2))
cat("In the dataframe `variable_details` there are", nrow(variable_details), "rows and", ncol(variable_details), "columns", "\n\n")
```

## Structure of the worksheet `variable_details`

### Naming convention for not applicable and missing values

`rec_with_table()` uses the `tagged_na()` function from the [haven](https://www.rdocumentation.org/packages/haven/versions/2.1.1) package to tag not applicable responses as `NA(a)`, and missing values (don't know, refusal, not stated) as `NA(b)`. As you will see later, not applicable values are transformed to `NA::a`, and missing values are transformed to `NA::b`. See [tagged_na_usage](tagged_na_usage.html) for more information about `tagged_na()`.

### Rows

Each row in `variable_details` lists the instructions to transform a single category of a variable.

- An exception to this rule are the "don't know", "refusal", and "not stated" categories, which are combined as a single missing category.

The number of rows required for a transformed variable depends on the:

- Number of categories in the original variable, 
- **PLUS** the number of categories for "not applicable" or "missing" data, 
- **PLUS** an 'else' row to assign values that are not defined in other rows or fall outside of the variable's range of possible values.
- **multiplied** by the number of datasets where the original variable's categories are different 

For example, in dataset A, a categorical variable with 4 distinct categories, a "not applicable" category and the 3 missing categories (e.g., don't know, not asked, not stated), will have 7 rows: 

+ 4 for each distinct category

+ 1 for the not applicable category

+ 1 for the missing categories

+ 1 else row.

If in dataset B the categorical variable' distinct categories are the **identical** to dataset A, there are **7 rows**. 

If in dataset B the categorical variable' distinct categories are the **different** to dataset A, there are **14 rows**. 


**Note**: We recommend not combining variables if the variable has an important change between datasets. `variable_detailsdetails$notes` is used to identify issues that may be relevant when transforming the variable or category.

### Columns

Here we explain the columns in the worksheet `variable_details`.

**Table 1.** Summary of the source and level of information used for each column in the worksheet 'variable_details'.
```{r, echo=FALSE, results='hide', message=FALSE}
library(knitr)
library(kableExtra)

var_desc_table <- data.frame(
  Data_source = c(rep("Transformed",5), rep("original",3), "both"),
  Dataset = c(rep("",5), "databaseStart", rep("", 2), "notes"),
  Variable = c("variable *", "toType *", rep("", 3), "variableStart *", "fromType *", "variableStartlabel", "notes"),
  Categories = c("recTo *", "numValidCat", "catLabel", "catLongLabel", "units", "recFrom *", "catStartLabel", "", "notes")
)

```
```{r, echo=FALSE}
kable(var_desc_table) %>%
  kable_styling(full_width = T) %>%
  collapse_rows(columns = 1, valign = "top") %>%
  add_header_above(c("", "Level of information" = 3)) %>%
  footnote(symbol = c("Columns required for the function rec_with_table. All other columns are recommended but optional."))
```

The order of the columns within the worksheet `variable_details` is not important because recodeflow functions use the column names.


1. **variable:** the name of the final transformed variable.

```{r, echo=FALSE, warning=FALSE}
kable(variable_details[7:13, 1], col.names = 'variable')
```

2. **typeEnd:** the data type of the final transformed variable. If the transformed variable is continuous fill in as `cont`; if the transformed variable that is categorical fill in as `cat` .

```{r, echo=FALSE, warning=FALSE}
kable(variable_details[c(7:13), c(1:2)])
```

3. **typeStart:** the variable type as indicated in datasets. As indicated in the **toType** column, categorical variables are denoted as `cat` and continuous variables are denoted as `cont`.

```{r, echo=FALSE, warning=FALSE}
kable(variable_details[c(7:13), c(1:3)])
```

4. **databaseStart:** the datasets that contain the variable and categories of interest, separated by commas.

```{r, echo=FALSE, warning=FALSE}
kable(variable_details[c(7:13), c(1:4)])
```

5. **variableStart:** the original names of the variables as they are listed in the original datasets, separated by commas. 

- If the variable name in a particular dataset is different from the transformed variable name, write out the dataset name, add two colons, and write out the original variable name for that dataset. 
- If the variable name in a particular dataset is the same as the transformed variable name, write the variable name in square brackets. Note: this only needs to be written out **once**.

```{r, echo=FALSE, warning=FALSE}
kable(variable_details[c(7:13), c(1:5)])
```

6. **variableStartLabel:** short form label describing the original variable.

```{r, echo=FALSE, warning=FALSE}
kable(variable_details[c(7:13), c(1:6)])
```

7. **numValidCat:** the number of categories for the transformed variable. This only applies to variables in which the **toType** is cat. For continuous variables, `numValidCat = N/A`. Note that for categories: not applicable, missing, and else, are not included in the category count. This column is not necessary for the function `rec_with_table()`.

```{r, echo=FALSE, warning=FALSE}
kable(variable_details[c(7:13), c(1:7)])
```

8. **recEnd:** the category of the categorical value your transforming to. For the not applicable category, write `NA::a` and for missing and else categories, write `NA::b`. For continuous variables that are not transformed in type, you would write in this column `copy` so that the function copies the values without any transformations.

```{r, echo=FALSE, warning=FALSE}
kable(variable_details[c(7:13), c(1:8)])
```

+ For categorical variables that remain categorical (i.e. from: cat -> to: cat), it is ideal to retain the same values as indicated in the original datasets.
+ For categorical variables that have changed in type (i.e from: cat -> to: cont), you will have to develop values that make the most sense to your analysis. For example, for variables that change from: cat -> to: cont, you can choose the categories' lower bound, mid-point, or upper-bound for the continuous value.

9. **catLabel:** short form label describing the category of a particular variable.

```{r, echo=FALSE, warning=FALSE}
kable(variable_details[c(7:13), c(1:9)])
```

10. **catLabelLong:** more detailed label describing the category of a particular variable. If the category is unchanged from original data, this label should be identical to what is recorded in the original data's documentation (e.g., the exact survey question). For derived variables, you can create your own long label.

```{r, echo=FALSE, warning=FALSE}
kable(variable_details[c(7:13), c(1:10)])
```

11. **units:** the units of a particular variable. If there are no units for the variable, write `N/A`. Note, the function will not work if there different units between the rows of the same variable (e.g. if the concentration of a single molecule has two records one recorded as mg/dl and the other recorded as g/dl).

```{r, echo=FALSE, warning=FALSE}
kable(variable_details[c(7:13), c(1:11)])
```

12. **recStart:** the range of values for a particular category in a variable as indicated in the original data. See data documentation and use the smallest and large values as your range to capture all values across the datasets. 

The rules for each category of a new variable are a string in `recFrom` and value in `recTo`. These recode pairs are the same syntax as interval notation in which a closed range of values are specified using square brackets. See [Notations for intervals](https://en.wikipedia.org/wiki/Interval_(mathematics)) for more information on interval notation. Recode pairs are obtained from the RecFrom and RecTo columns
  *value range* is indicated by a comma, e.g. `recFrom= [1,4]; recTo = 1` (recodes all values from 1 to 4 into 1}
  *value range* for double vectors (with fractional part), all values within the specified range are recoded; e.g. `recFrom = [1,2.5]; recTo = 1` recodes 1 to 2.5 into 1, but 2.55 would not be recoded (since it's not included in the specified range).
  *NA* is used for missing values (don't know, refusal, not stated)
  *else* is used all other values, which have not been specified yet, are indicated by `else`, e.g. `recFrom = "else"; recTo = NA` (recode all other values (not specified in other rows) to "NA")}
  *copy* the `else` token can be combined with `copy`, indicating that all remaining, not yet recoded values should stay the same (are copied from the original value), e.g. `recFrom = "else"; recTo = "copy"`

```{r, echo=FALSE, warning=FALSE}
kable(variable_details[c(7:13), c(1:9)])
```

13. **catStartLabel:** label describing each category. This label should be identical to what is shown in the original data documentation. For the missing rows, each missing category is described along with their coded values. You can import labels from a survey's DDI files using `bllflow` helper functions. See [bllflow documentation](http://bllflow.projectbiglife.ca).

```{r, echo=FALSE, warning=FALSE}
kable(variable_details[c(7:13), c(1:13)])
```

14. **notes:** any relevant notes to inform the user running the `recode-with-table` function. Things to include here would be changes in wording across datasets, missing/changes in categories, and changes in variable type across datasets.

```{r, echo=FALSE, warning=FALSE}
kable(variable_details[c(7:13), c(1:14)])
```

## Derived Variables

The same naming convention applies to derived variables with the exception of two columns:

1. In **variableStart**, instead of database names being listed, **DerivedVar::** is written followed with the list of original variables used inside square brackets. 
+ `DerivedVar::[var1, var2, var3]`

2. In **recTo**, write **Func::** followed with the exact name of the custom function used to create the derived variable.
+ `Func::derivedFunction`

A derived variable looks like this in `variable_details.csv`

```{r, echo=FALSE, warning=FALSE}
kable(variable_details[64,1:14])
```
